section .data
    newline db 10
    newline_len equ 1
    digitSpace resb 100
    digitSpacePos resb 8
    buff resb 11

section .text
global _start
write:
    mov rcx, digitSpace
    mov rbx, 10
    mov [rcx], rbx
    ; inc rcx
    mov [digitSpacePos], rcx

_write_loop:
    mov rdx, 0
    mov rbx, 10
    div rbx
    push rax
    add rdx, 48
 
    mov rcx, [digitSpacePos]
    mov [rcx], dl
    inc rcx
    mov [digitSpacePos], rcx
    
    pop rax
    cmp rax, 0
    jne _write_loop

_write_loop2:
    mov rcx, [digitSpacePos]
 
    mov rax, 1
    mov rdi, 1
    mov rsi, rcx
    mov rdx, 1
    syscall
 
    mov rcx, [digitSpacePos]
    dec rcx
    mov [digitSpacePos], rcx

    cmp rcx, digitSpace
    jge _write_loop2

    cld                   ; Clear direction flag (to increment destination pointer)
    mov rcx, 100          ; Set the count to 100 bytes
    mov rdi, digitSpace   ; Set the destination pointer to digitSpace

    mov al, 0             ; Set the value to be stored (0 in this case)
    rep stosb             ; Store AL (0) in memory, incrementing destination pointer (EDI), repeat ECX times

    ret
read:
    ; Syscall to read input
    mov rax, 0            ; sys_read
    mov rdi, 0            ; file descriptor 0 (stdin)
    mov rsi, buff         ; buffer to store input
    mov rdx, 11           ; maximum number of bytes to read
    syscall               ; interrupt to call kernel

    ; Convert input string to integer
    mov rsi, buff         ; RSI points to the input buffer
    xor rax, rax          ; Clear RAX (result)
    xor rdi, rdi          ; Clear RDI (multiplier)

_read_loop:
    movzx rcx, byte [rsi]  ; Load current byte into RCX
    cmp rcx, 0x0A          ; Check for newline character
    je _read_done          ; If newline, we're done
    sub rcx, '0'           ; Convert ASCII to integer
    imul rax, rax, 10      ; Multiply current result by 10
    add rax, rcx           ; Add the current digit to the result
    inc rsi                ; Move to the next character
    jmp _read_loop         ; Repeat for next character

_read_done:
    ret

_start:


; BB1
push rdi
push rsi
push rdx
push rcx
call read
pop rcx
pop rdx
pop rsi
pop rdi
mov rax, rbx
add rax, rbx
cmp rax, 0
jge branch7

; BB2
mov rbx, rax
add rbx, rax
mov rax, rbx
jmp branch8

; BB3
branch7:

; BB4
branch8:
push rbx
push rcx
push rdx
push rdi
push rsi
call write
pop rsi
pop rdi
pop rdx
pop rcx
pop rbx
mov rax, 60
mov rdi, 0
syscall
